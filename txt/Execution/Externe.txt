EXTERNE :

- RÃ©cupÃ©rer la commande et vÃ©rifier si elle est exÃ©cutable.
- Chercher son chemin dâ€™accÃ¨s si lâ€™utilisateur a entrÃ© un nom sans chemin absolu.
- CrÃ©er un processus fils (fork()) pour exÃ©cuter la commande.
- ExÃ©cuter la commande avec execve().
- GÃ©rer les erreurs et attendre la fin du processus.


Lorsquâ€™un utilisateur entre une commande, on doit dâ€™abord dÃ©terminer si elle est exÃ©cutable directement.

Les processus fonctionnent comme un arbre avec des branches.
getpid() pour obtenir l'ID du process
getppid() pour obtenir l'ID du process parent

Chaque appele du process donnera un pid different, car il sagit d'un nouveau process.

CMD [ps] affiche les processus en cours d'execution sur le systeme.

Tuer un processus en cours d'execution CMD [kill] (SIGTERM == signal envoye pour terminer le process)

Deux facons de crÃ©er un process

    1. Utiliser system

    2. Utiliser fork et exec
        - fork()
            -> Produit un process fils qui est l'execte copie de son processus parent.
            -> Le process parent continue d'executer le programme a partir de l'endroit ou fork est appele.
            -> Le process enfant fait la meme chose au meme endroit 
https://mtodorovic.developpez.com/linux/programmation-avancee/?page=page_3



        - exec()
            -> Fait en sorte qu'un process cesse d'etre une instance d'un certain programme et devient une instance d'un autre.



Comment executer les CMD externes ?

Contrairement aux builtins les CMD externes seront lancees directement avec leur vrai binaire depuis le shell.
Nous avons donc une ligne de commande splitter en argument grace au parsing.
    Exemple : 
        (1) ls -l /home
        (2) tab_arg = ["ls", "-l", "/home", NULL]

Dans cette exemple l'utilisateur tape ls mais ne donne pas le chemin dans le binaire.
Pour pouvoir rÃ©cupÃ©rer le programme demander pas l'utilisateur (ici ls) nous allons devoir crÃ©er un doublons.
Ce doublons sera la pour conserver Ãªtre remplacÃ© par le programme de la CMD voulu.
De cette facon en continue Ã  exÃ©cuter notre code tout en exÃ©cutant le programme associer Ã  la CMD.
Si on de crÃ©eait pas de doublons le p    e PID mÃªme aprÃ¨s execve(), car câ€™est le mÃªme processus, juste transformÃ©.

    Le child ne "renvoie" rien lui-mÃªme : câ€™est le noyau qui informe le parent Ã  la fin du processus via waitpid().

Tu veux maintenant que je tâ€™explique comment lire la variable $PATH pour retrouver le bon chemin binaire (ex : /bin/ls) Ã  passer Ã  execve() ? ðŸ”rogramme de la commande s'exÃ©cuterait et se terminerait directement aprÃ¨s.
Pour crÃ©er notre doublons nous allons faire appele Ã  la fonction fork().

fork()
    -> pid_t fork(void)
    -> CrÃ©e un nouveau processus appele processus enfant (child)
    -> Le processus original est appele processus parent
    -> #include <unistd.h>
    -> Fork() est appele 1x mais retourne 2x 
    -> Return 
        - Return (0) dans le processus fils.
        - Return le PID du fils dans le processus parent.
        - Return (-1) en cas d'erreur (Ã©chec de crÃ©ation du processus).

Une fois le child process prÃªt nous allons chercher dans la variable $PATH le chemin vers la CMD si cette derniÃ¨re existe belle et bien.
Une fois que le bon chemin est trouvÃ© on le passe Ã  la fonction execve().
Execve() va nous permettre de remplacer le child process par le programme de la commande que nous avons cherchÃ© prÃ©cÃ©demment (ici ls).
Une fois le child remplacÃ© le programme de la CMD s'exÃ©cutera normalement.

execve()
    -> int execve(const char *pathname, char *const argv[], char *const envp[]);
    -> Remplace le processus courant par un nouveau programme.
    -> Arguments : 
        - const char *pathname : Chemin absolu du programme Ã  exÃ©cuter
        - char *const argv[] : tableau de chaÃ®nes reprÃ©sentant la commande et ses arguments
        - char *const envp[] : tableau des variables dâ€™environnement (gÃ©nÃ©ralement celui de ton shell)
    -> Le code du processus courant est Ã©crasÃ© par le programme cible.
    -> Le PID ne change pas.
    -> Return (-1) en cas d'Ã©chec.

Pendant ce temps le process parent sera en attente de la fin de la CMD.
On retrouvera dans le process parent la fonction waitpid() ayant comme argument le PID du child.

waitpid()
    -> pid_t waitpid(pid_t pid, int *status, int options);
    -> Arguments
        - pid_t pid : Le PID du processus quâ€™on veut attendre.
            -> (>0) attendre ce PID prÃ©cis.
            -> (-1) attendre nâ€™importe quel fils.
        - int *status : Pointeur vers un int oÃ¹ sera stockÃ© le code de retour du fils.
        - int options : Options (souvent 0, mais tu peux mettre WNOHANG, etc).
    -> Return le PID du processus qui sâ€™est terminÃ©.
    -> Return (-1) en cas dâ€™erreur.
    -> Le shell se bloque et attend que le processus pid termine.
    -> Une fois que ce processus sâ€™est terminÃ©, waitpid() :
        - Return son PID + remplit status avec des informations sur la fin du processus.



